# 객체지향 프로그래밍

## 개념
인간은 자연스럽게 현실세계의 모든 것들을 하나 하나의 개체로 생각하며 관념적으로 묶는다.
  
예를 들면 우리는 땅에 굴러다니는 단단한 것들을 '돌멩이'로 생각한다. 또한 화학적으로 Fe 성분을 가지는 단단한 것을 '철'이라고 생각한다.
만약, 신석기시대에 누군가 무심코 철이라는 것을 발견했다고 생각해보자.  
그럼 그 사람은 그것을 '철'이라고 생각했을까? 아니면 조금 더 단단한 '돌멩이'라고 생각했을까?  

'철'이라고 생각했을 수도 있고, '돌멩이'라고 생각했을 수도있다. 정답은 알수없는 것이다.  
하지만 그 사람이 그 개체를 어떻게 받아들이는지에 대한 메커니즘을 생각해보자.  
그 사람은 '철'과 '돌멩이'가 '단단한 것'이라는 공통적인 범주에 속한다고 받아들였다면 자연스럽게 '조금 더 단단한 돌멩이' 정도로 받아들였을 것이고  
'철'이 '돌멩이'와 다른 차이점을 발견하고 다른 무언가라고 대상화했을 때 분리될 것이다.

이처럼 '공통화'와 '대상화'를 통해서 인간은 객체지향적으로 생각한다고 본다.  
이것을 프로그래밍에도 적용함으로써 코드를 더 구조적으로 설계할 수 있게 되는 것이다.

이런 객체지향의 개념은 완성된 비객체지향 언어인 C언어인 더 먼저 나온 개념이다.  
하지만 비교적 최근에 많이 사용하기 시작한 이유는 첫째는 과거의 하드웨어로 객체지향설계를 하기에는 성능적인 부담이 존재했다.
두번째로는 인간은 자연스럽게 세상을 객체지향적인 눈으로 바라보지만, 객체지향적인 코드는 절차지향보다 이해하기 어려워한다는 것이다.  
당연시 뇌에서 해주는 일인만큼 자연스러운 것이기 때문에 그 메커니즘을 인지하지 못하기 때문이다.  

이런 객체지향 설계에 있어서 흔히 4가지 특징을 말한다.  
**Abstraction(추상화)** / **Encapsulation(캡슐화)** / **Inheritance(상속)** / **Polymorphism(다형성)**  
이 4가지 특징을 하나하나 잘 살펴보자.

## Abstraction(추상화)
추상화(abstraction)는 관념의 공통화, 대상화이다. 객체지향의 출발점이라 말할 수 있을 것이다.  
추상화는 프로세스(process) 추상화 / 데이터(data) 추상화로 나눌 수 있다.

프로세스 추상화는 구조적 프로그래밍에서 나온 개념이다.  
프로그램을 만들 때 우리는 프로그램이 수행되어야 할 기능들을 생각해야하고,  
이를 토대로 함수를 설계할 수 있을 것이다.  
쉽게 생각하면 특정 기능을 수행하는 함수나 메서드들을 의미한다고도 할 수 있다.

데이터 추상화는 프로그램에 필요한 데이터의 추상화를 의미한다.  
프로그램은 항상 어떤 데이터를 묶어 추상화하고 이와 관련된 연산들을 추상화할 수 있을 것이다.  
즉, 클래스기반 언어에서 클래스를 의미한다고 할 수 있다. 
  
일대일 대전게임을 만든다고 생각해보자.  
이 게임을 구현하는데 있어서 어떤 부분들을 추상화 할 수 있을까?  
기본적으로 게임현황판, 유저, 공격수단 등을 추상화 할 수 있을 것이다.
  
예제들을 살펴보며 생각해보자.
~~~javascript
var user1Hp = 10;
var user2Hp = 10;

var user1Damage = 2;
var user2Damage = 2;

function user1AttackUser2() {
  user2Hp -= user1Damage;
}

function user2AttackUser1() {
  user1Hp -= user2Damage;
}

function displayStatus() {
  console.log('user1: ' + user1Hp);
  console.log('user2: ' + user2Hp);
}
~~~
위의 예제를 살펴보면 프로세스 추상화가 어느정도 진행된 것을 확인할 수 있다.  
프로세스 추상화를 통해서 코드를 어느정도 쉽게 이해할 수 있게 되었다.  
그런데 만약 user가 100명이라면..?

다음 예제를 살펴보자.
~~~javascript
var hp = {
  user1: 10,
  user2: 10
};

var damage = {
  user1: 10,
  user2: 10
}

function attack(suspect, victim) {
  hp[victim] -= damage[suspect];
}

function display() {
  for (var user in hp) {
    if (hp.hasOwnProperty(user)) {
      console.log(user + ': ' + hp[user]);
    }
  }
}
~~~
이 예제에서는 프로세스 추상화와 함께 데이터의 추상화가 진행한 것을 볼 수있다.  
생명력이 hp, 공격력이 damage 로 데이터가 추상화된 것을 볼 수 있다.
또한 attack 이 하나의 연산으로서 추상화 되었고
display 라는 프로세스가 추상화되었다.
  
이전 예제보다 더 확장성 있게 설계되었지만 아직 우리는 user 를 더 용이하게 관리할 수 있을 듯 보인다.
~~~javascript
class User {
  constructor(hp, damage) {
    this.hp = hp;
    this.damage = damage;
  }
  
  attack(targetUser) {
    targetUser.hp -= this.damage;
  }
}

class Game {
  constructor() {
    this.users = null;
  }
  
  start() {
    this.users = [];
  }
  
  addUser(user) {
    this.users.push(user);
  }
  
  display() {
    this.users.forEach((user, index) => {
      console.log(`user${index}: ${user.hp}`)
    })
  }
}
~~~
이렇게 설계해보면 우리는 User 와 Game 을 하나의 데이터 추상화를 했다.  
코드를 이해하기도 쉬워졌을 뿐 아니라, 추상화를 통해 재사용성을 높임으로써   
여러 게임이 동시에 진행되는 경우, 여러 유저가 참여하는 경우에 대비해서  
훨씬 확장성있게 설계되었다.

이처럼 추상화를 할때는 어떤 것을 추상화해야하는지가 중요하다.  
항상 공통점을 묶고, 불필요한 공통점을 제거하려는 노력을 해야한다.  
즉, 하나의 추상화는 하나의 **책임**을 갖도록 노력해야한다.

## Encapsulation(캡슐화)
우리가 두통 때문에 타이레놀(타이레놀이 알약은 아니지만 알약이라고 가정하자)을 먹어야하는 상황이 있다.  
우리는 타이레놀 안에 어떤 성분들이 들어있는지 전부 확인하면서 먹을까?  
아니다. 우리는 타이레놀이라는 알약이 두통을 완화시켜준다는 기능만을 생각하고 타이레놀(알약)을 먹으면 된다.  

위의 예를 보면 우리는 여러 성분들을 타이레놀이라는 하나의 캡슐로 대상화함으로써 독립적인 모듈로 생각했다.  
또한, 하나의 캡슐로 묶음으로써 우리는 정보를 은닉할 수도 있다.  
타이레놀을 만든사람이 알약을 절대 열어볼수 없고 위산에 의해서만 열리도록 만들어 두면, 복용자 입장에서는 성분을 알 수 없을 것이다.  
이처럼 캡슐화는 설계하기에 따라서 정보 은닉의 특징도 가지고 있다.

자바스크립트 예제로 만들어보자.  
만약 우리가 키값을 생성해주는 keyGenerator 를 만든다고 생각하자.
~~~javascript
var keyGenerator = {
  key: 0,
  get: function() {
    return this.key++;
  }
}

keyGenerator.get(); // 0
keyGenerator.get(); // 1
~~~
위와 같이 `keyGenerator` 를 대상화함으로써 우리는 `.get()` 메서드 호출만으로 사용할 수 있다.  
하지만 `keyGenerator.key` 를 통해서 사용자가 직접접근할 수 있는 위험이 존재한다.  
자바스크립트에서는 이것을 클로저를 활용해서 은닉시킬 수 있다.
~~~javascript
function KeyGenerator() {
  var key = 0;
  return {
    get: function() {
      return key++;
    }
  }
}

var keyGenerator = KeyGenerator();
keyGenerator.get(); // 0
keyGenerator.get(); // 1
~~~
key 값을 은닉시킴으로써 사용자가 직접적으로 수정할 수 없는 변수로 만들었다.

OOP2.md 에서는 상속과 다형성에 대해서 다룰 예정이다.

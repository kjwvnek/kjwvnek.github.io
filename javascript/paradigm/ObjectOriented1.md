# 객체지향 프로그래밍

## 개념
인간은 자연스럽게 현실세계의 모든 것들을 하나 하나의 개체로 생각하며 관념적으로 묶는다.
  
예를 들면 우리는 땅에 굴러다니는 단단한 것들을 '돌멩이'로 생각한다. 또한 화학적으로 Fe 성분을 가지는 단단한 것을 '철'이라고 생각한다.
만약, 신석기시대에 누군가 무심코 철을 발견했다고 생각해보자.  
그럼 그 사람은 그것을 '철'이라고 생각했을까? 아니면 조금 더 단단한 '돌멩이'라고 생각했을까?  

'철'이라고 생각했을 수도 있고, '돌멩이'라고 생각했을 수도있다. 정답은 알수없는 것이다.  
하지만 그 사람이 그 개체를 어떻게 받아들이는지에 대한 메커니즘을 생각해보자.  
그 사람은 '철'과 '돌멩이'가 '단단한 것'이라는 공통적인 범주에 속한다고 받아들였다면 자연스럽게 '조금 더 단단한 돌멩이' 정도로 받아들였을 것이고  
'철'이 '돌멩이'와 다른 차이점을 발견하고 다른 무언가라고 대상화했을 때 분리될 것이다.

이처럼 '공통화'와 '대상화'를 통해서 인간은 객체지향적으로 생각한다고 본다.  
이것을 프로그래밍에도 적용함으로써 코드를 더 구조적으로 설계할 수 있게 되는 것이다.

이런 객체지향 프로그래밍의 개념은 비객체지향 언어인 C언어의 완성보다 먼저 나왔다.  
하지만 비교적 최근에 객체지향 프로그래밍을 많이 사용하기 시작한 이유는 첫째, 과거의 하드웨어로 객체지향설계를 하기에는 성능적인 부담이 존재했다.  
그리고 두번째는 객체지향 프로그래밍을 절차지향 프로그래밍보다 어려워한다는 것이다.  
인간은 분명 세상을 객체지향적인 눈으로 바라보지만, 뇌에서 알아서 해주는 자연스러운 일이기 때문에 그 메커니즘 자체를 인지하지 않기 때문이다.  

흔히들 객체지향 프로그래밍을 말할때, 4가지 특징들을 말한다.  
**Abstraction(추상화)** / **Encapsulation(캡슐화)** / **Inheritance(상속)** / **Polymorphism(다형성)**  
이 특징들을 하나하나 잘 살펴보자.

## Abstraction(추상화)
추상화(abstraction)는 관념의 공통화, 대상화이다. 객체지향의 출발점이라 말할 수 있을 것이다.  
그리고 이 추상화는 프로세스(process) 추상화 / 데이터(data) 추상화로 나눌 수 있다.

**프로세스 추상화**는 구조적 프로그래밍에서 나온 개념이다.  
프로그램을 만들 때 우리는 이 프로그램이 수행해야 할 기능들을 생각하고, 이를 토대로 함수를 설계할 수 있을 것이다.  
이처럼 '기능'을 중심으로 추상화 하는 것을 '프로세스 추상화'라고 한다.
쉽게 생각하면 특정 기능을 수행하는 '함수'나 '메서드'들을 의미한다고도 할 수 있다.  

**데이터 추상화**는 프로그램에 필요한 데이터 중 공통적인 부분을 묶고 대상화하는 것을 의미한다.  
우리는 프로그램을 구성하는 요소들 중 어떤 데이터들과 이와 관련된 연산들을 묶어서 추상화할 수 있을 것이다.  
코드로 구현하는 관점에서 볼때, 자바스크립트에서는 일반 객체, 클래스기반 언어에서 클래스를 의미한다. 
  
일대일 대전게임을 만든다고 생각해보자.  
이 게임을 구현하는데 있어서 어떤 부분들을 추상화 할 수 있을까?  
기본적으로 게임현황판, 유저, 공격수단 등을 추상화 할 수 있을 것이다.
  
예제들을 살펴보며 생각해보자.
~~~javascript
var user1Hp = 10;
var user2Hp = 10;

var user1Damage = 2;
var user2Damage = 2;

function user1AttackUser2() {
  user2Hp -= user1Damage;
}

function user2AttackUser1() {
  user1Hp -= user2Damage;
}

function displayStatus() {
  console.log('user1: ' + user1Hp);
  console.log('user2: ' + user2Hp);
}
~~~
위의 예제를 살펴보면 `user1AttackUser2` 와 `user2AttackUser1`, `displayStatus` 를 통해서 '프로세스 추상화'를 진행했다.  
이렇게 우리는 프로세스 추상화를 통해서 코드를 어느정도 더 쉽게 이해할 수 있게 되었다.  
그런데 만약 이 프로그램에서 user가 100명이 필요하다면..?

다음 예제를 살펴보자.
~~~javascript
var hp = {
  user1: 10,
  user2: 10
};

var damage = {
  user1: 10,
  user2: 10
}

function attack(suspect, victim) {
  hp[victim] -= damage[suspect];
}

function display() {
  for (var user in hp) {
    if (hp.hasOwnProperty(user)) {
      console.log(user + ': ' + hp[user]);
    }
  }
}
~~~
이 예제에서는 생명력(hp)이 하나의 공통적인 데이터라 생각했고, 공격력(damage)을 또 하나의 공통적인 데이터라 생각했다.  
그리고 이 데이터를 활용한 하나의 연산을 `attack` 이라고 추상화했다. 이렇게 데이터 추상화를 진행했고,  
`display` 함수를 통해서 프로세스를 추상화했다.
  
이전 예제보다 더 확장성 있게 설계되었지만 아직 우리는 user 를 더 용이하게 관리할 수 있을 듯 보인다.
~~~javascript
class User {
  constructor(hp, damage) {
    this.hp = hp;
    this.damage = damage;
  }
  
  attack(targetUser) {
    targetUser.hp -= this.damage;
  }
}

class Game {
  constructor() {
    this.users = null;
  }
  
  start() {
    this.users = [];
  }
  
  addUser(user) {
    this.users.push(user);
  }
  
  display() {
    this.users.forEach((user, index) => {
      console.log(`user${index}: ${user.hp}`)
    })
  }
}
~~~
이렇게 설계함으로써 우리는 `User` 와 `Game`을 데이터 추상화로 다뤘다.  
코드를 이해하기도 쉬워졌을 뿐 아니라, 추상화를 통해 재사용성을 높임으로써   
여러 게임이 동시에 진행되는 경우, 여러 유저가 참여하는 경우에 대비해서  
훨씬 확장성있게 설계되었다.

이처럼 추상화를 할때는 어떤 것을 추상화 해야하는지가 중요하다.  
항상 공통점을 묶고, 불필요한 공통점을 제거하려는 노력을 해야한다.  
즉, 하나의 추상화는 하나의 **책임**을 갖도록 노력해야한다.

## Encapsulation(캡슐화)
우리가 두통 때문에 타이레놀을 먹어야하는 상황이 있다.(타이레놀이 캡슐 형태는 아니지만 캡슐이라고 가정하자)  
우리는 타이레놀 안에 어떤 성분들이 들어있는지 전부 확인하면서 먹을까?  
아니다. 우리는 타이레놀이라는 '캡슐'이 두통을 완화시켜준다는 기능만을 생각하고 타이레놀(캡슐)을 먹으면 된다.  

우리는 위에서 여러 성분들을 타이레놀이라는 하나의 캡슐로 묶어서 독립적인 모듈로 만들었다.  
만약 타이레놀을 만든 사람이 캡슐을 절대 열어볼수 없고 위산에 닿을때만 열리도록 설계한다면, 복용자 입장에서는 성분을 알 수 없을 것이다.  
이처럼 캡슐화는 설계하기에 따라서 정보 은닉의 특징도 가지고 있다.

그렇다면 자바스크립트 예제로 만들어보자.  
만약 우리가 키값을 생성해주는 keyGenerator 를 만든다고 생각하자.
~~~javascript
var keyGenerator = {
  key: 0,
  get: function() {
    return this.key++;
  }
}

keyGenerator.get(); // 0
keyGenerator.get(); // 1
~~~
위와 같이 `keyGenerator` 를 캡슐화함으로써 우리는 이 캡슐에 무엇이 들었는지 확인할 필요없이 `.get()` 메서드 호출만으로 원하는 기능을 수행할 수 있다.  
하지만 이런 설계는 `keyGenerator.key` 를 통해서 사용자가 직접 정보에 접근할 수 있는 위험이 존재한다.  
자바스크립트에서는 이것을 클로저를 활용해서 은닉시킬 수 있다.
~~~javascript
function KeyGenerator() {
  var key = 0;
  return {
    get: function() {
      return key++;
    }
  }
}

var keyGenerator = KeyGenerator();
keyGenerator.get(); // 0
keyGenerator.get(); // 1
~~~
`key` 값을 은닉시킴으로써 사용자가 직접적으로 수정할 수 없는 변수로 만들었다.  
객체지향 설계 관점에서 정보은닉은 분명 더 안전한 설계지만, 자바스크립트에서 클로저 활용은 메모리낭비로 이어질 수 있다.  
이 부분을 염두하면서 설계하자.

OOP2.md 에서는 상속과 다형성에 대해서 다룰 예정이다.
